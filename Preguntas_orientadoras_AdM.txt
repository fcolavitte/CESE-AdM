Preguntas orientadoras
1. Describa brevemente los diferentes perfiles de familias de microprocesadores/microcontroladores de ARM. Explique alguna de sus diferencias características.

Los microprocesadores/microcontroladores ARM se clasifican en Application(A), Real Time (R) y Microcontroller(M).
- Cortex A: Procesadores de elevado performance preparados para correr sistemas operativos. Estos OS se alejan de los RTOS dado a que los Cortex A poseen memoria caché lo que genera tiempos de acceso a datos no constantes.
- Cortex R: Procesadores destinados a RTOS, con una arquitectura diseñada para posser un elevado performance sin perder la referencia de tiempo garantizando el procesamiento en tiempo real.
- Cortex M: Microcontroladores de uso genérico para sistemas embebidos, con caracteristicas de bajo consumo y orientado a bare-metal y RTOS como FreeRTOS.

------------------------------------------------------------------------------------------------------------------
Cortex M
1. Describa brevemente las diferencias entre las familias de procesadores Cortex M0, M3 y
M4.

- M0: Microcnontroladores de consumo masivo, de bajo coste y baja capacidad de procesamiento en comparación a M3 y superiores. Orientado principalmente al manejo de puertos GPIO y procesamiento general de datos. En general de bajo consumo energético.
- M3: Mayor performance que la familia M0, con capacidad de procesamiento avanzado de datos. Pueden poseer memory protection unit.
- M4: Similares a los M3, levemente superiores. Agregan funciones como SIMD, soportan FPU por hardware e incluyen instrucciones para trabajar con aritmética saturada.

2. ¿Por qué se dice que el set de instrucciones Thumb permite mayor densidad de código?
Explique
El set de instrucciones Thumb está compuesto por un conjunto reducido de instrucciones de 16bits las cuales son las más comunes de utilizar.


			32bits			│\
Memoria Flash ───┬──────────────────────────────│ \
		 │				│  │
		 │		│\		│  │
		 │0:15bits	│ \		│  │─────────> Ejecución de la instrucción
		 ├──────────────│  │  32 bits	│  │
		 │		│  │────────────│ /
		 │16:32 bits	│  │		│/(**)
		 └──────────────│ /
		 		│/
				(*)
(*): Selección de primeros 2 o últimos 2 bytes de los 4 bytes guardados en la flash. Selecciona una instrucción u otra de 16 bits de una posición de memoria de 32bits.
     └─>A partir de la instrucción Thumb de 16bits construye su equivalente de 32 bits para ser ejecutado.
(**): Selecciona entre ejecutar directo de memoria Flash (32bits) o ejecutar de 2 bytes (16bits instrucciones Thumb).
Ej. de instrucción en 32bits vs 2 de 16 en thumb:
>> 32bits:
		┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
Instrcción #1:  │31│30│29│28│27│26│25│24│23│22│21│20│19│18│17│16│15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│	//Primeros 4 bytes
		└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
		┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
Instrcción #2:  │31│30│29│28│27│26│25│24│23│22│21│20│19│18│17│16│15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│	//Segundos 4 bytes
		└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
>> Thumb (16bits):
		┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐ ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
Instrcción #1:  │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│ │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│-> Instrucción #2	//Primeros 4 bytes
		└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘ └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
		┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐ ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
Instrcción #3:  │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│ │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│-> Instrucción #4	//Segundos 4 bytes
		└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘ └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
Conclusión: Se consigue mayor densidad de instrucciones en igual capacidad de memoria de programa.
Como desventajas, estas instrucciones son reducidas, no están "traducidas" a Thumb el 100% de las instrucciones de 32bits.
Por lo que para ciertas acciones a realizar por el código, puede consumir más instrucciones en Thumb que en 32bits.

3. ¿Qué entiende por arquitectura load-store? ¿Qué tipo de instrucciones no posee este
tipo de arquitectura?
La arquitectura de ARM no trabaja directamente con los datos guardados en RAM, sino que trabaja con los registros.
Para esto se tienen tres pasos:
> 1: Para acceder a los datos se utiliza la función de "load" la cual mueve un valor guardado en RAM a un registro, generalmente de 0 a 12 y en el caso de Thumb de 0 a7.
> 2: Se opera con los valores que se encuentran en los registros de propósito general.
> 3: De requerirse, se guarda el resultado en RAM moviendo el valor desde uno de los registros de propósito general con la función "store".
Existen distintas funciones para movimiento de datos:

REG  ‐‐> REG: transferencia entre dos registros
MEM  ‐‐> REG: carga (load) 		>> De memoria a un registro para ser utilizado
PILA ‐‐> REG: extracción (pop)
REG  ‐‐> MEM: almacenamiento (store)	>> De un registro a memoria para ser almacenado
MEM  ‐‐> MEM: movimiento (move)
PILA ‐‐> MEM: extracción (pop)
REG  ‐‐> PILA: inserción (push)
MEM  ‐‐> PILA: inserción (push)

Existen operaciones que no requieren operar sobre registros y por ende no requiere una función load previa, por ejemplo NOP.

4. ¿Cómo es el mapa de memoria de la familia? 
Dado la arquitectura de 32bits, se poseen 2^32 (4.294.967.296) posiciones de memoria, lo que corresponde a 4GB.
Dentro de la arquitectura ARMv7 correspondiente a M3 y M4:
Los primeros 0,5GB corresponden a memoria de programa, luego 0,5 a SRAM, 0,5 Perisféricos, 1G RAM, 1GB para dispositivos y 0,5GB específico para el sistema.

  	    ┌────────┐
0xFFFFFFFF  │ 	     │
	    │ System │	0,5GB
0xE0000000  │        │
	    ├────────┤
0xDFFFFFFF  │ 	     │
	    │ Devices│	1GB
0xA0000000  │        │
	    ├────────┤
0x9FFFFFFF  │ 	     │
	    │ RAM    │	1GB
0x60000000  │        │
	    ├────────┤
0x5FFFFFFF  │ 	     │
	    │ Perisfé│	0,5GB
0x40000000  │ -ricos │
	    ├────────┤
0x3FFFFFFF  │ 	     │
	    │ SRAM   │	0,5GB
0x20000000  │        │
	    ├────────┤
0x1FFFFFFF  │ 	     │
	    │ Código │	0,5GB
0x00000000  │        │
	    └────────┘
Dentro de SRAM y Perisféricos, el primer MB corresponde a bit band, manejados por las posiciones relativas de 32MB a 64MB de cada bloque.

5. ¿Qué ventajas presenta el uso de los “shadowed pointers” del PSP y el MSP?
Tanto MSP como PSP son particiones de la pila.
MSP: Main Stack Pointer
PSP: Processor Stack Pointer

En bare-metal se utiliza el MSP como única pila. Mientras que en RTOS solo el kernel e interrupciones tiene acceso a el MSP, mientras que las "task" acceden a las PSP de cada tarea.
Cada stack pointer tiene una capacidad determinada que puede ser modificada. Cada tarea solo puede acceder a su PSP y no al de otros ni al MSP.
En RTOS la MPU (Memory Protection Unit) define qué parte de la pila puede acceder cada task.
Para cada PSP y el MSP la función PUSH y POP maneja la pila referida a la tarea que se está ejecutando o el kernel, protegiendo al resto de las particiones de la pila.
En caso de que una task esté corrupta no puede modificar otros PSP ni el MSP por lo que el error no se propaga. Tampoco una task puede modificar los PSP de otras task.

6. Describa los diferentes modos de privilegio y operación del Cortex M, sus relaciones y como se conmuta de uno al otro.
   Describa un ejemplo en el que se pasa del modo privilegiado a no priviligiado y nuevamente a privilegiado.

Existe el thread mode y handler mode.
El modo thread es la ejecución normal del programa, al igual que en bare-metal. Mientras que el handler mode es el código que se ejecuta por medio de una interrupción.
A su vez el sistema se puede configurar en modo privilegiado y no privilegiado. En bare-metal se ejecuta el código en modo privilegiado.
Cuando se usa un RTOS, el kernel se ejecuta en modo privilegiado mientras que las task se ejecutan en modo no privilegiado.
En modo no privilegiado las task solo pueden acceder a su PSP (Processor Stack Pointer) sin poder modificar el de otra task ni el MSP.
El kernel tras realizar la configuración de las task pasa a modo no privilegiado y ejecuta la task de mayor priordad.
Al ocurrir una interrupción del systick se pasa al modo privilegiado por estarse ejecutando una interrupción.
Esta pasa el modo a privilegiado para llamar al kernel, el cual define la proxima tarea a realizar en caso de que se requiera un cambio y vuelve a cambiar el modo a no privilegiado para ejecutar la task.
De modo privilegiado se puede pasar en cualquier momento a no privilegiado. Pero para acceder a modo privilegiado únicamente se puede realizar al ocurrir una interrupción.
Es por esto que se requiere las interrupciones del systick para dar paso al kernel el cual corre en modo privilegiado.

7. ¿Qué se entiende por modelo de registros ortogonal? Dé un ejemplo

