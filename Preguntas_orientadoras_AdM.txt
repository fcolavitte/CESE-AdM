Preguntas orientadoras
1. Describa brevemente los diferentes perfiles de familias de microprocesadores/microcontroladores de ARM. Explique alguna de sus diferencias características.

Los microprocesadores/microcontroladores ARM se clasifican en Application(A), Real Time (R) y Microcontroller(M).
- Cortex A: Procesadores de elevado performance preparados para correr sistemas operativos. Estos OS se alejan de los RTOS dado a que los Cortex A poseen memoria caché lo que genera tiempos de acceso a datos no constantes.
- Cortex R: Procesadores destinados a RTOS, con una arquitectura diseñada para posser un elevado performance sin perder la referencia de tiempo garantizando el procesamiento en tiempo real.
- Cortex M: Microcontroladores de uso genérico para sistemas embebidos, con caracteristicas de bajo consumo y orientado a bare-metal y RTOS como FreeRTOS.

------------------------------------------------------------------------------------------------------------------
Cortex M
1. Describa brevemente las diferencias entre las familias de procesadores Cortex M0, M3 y
M4.

- M0: Microcnontroladores de consumo masivo, de bajo coste y baja capacidad de procesamiento en comparación a M3 y superiores. Orientado principalmente al manejo de puertos GPIO y procesamiento general de datos. En general de bajo consumo energético.
- M3: Mayor performance que la familia M0, con capacidad de procesamiento avanzado de datos. Pueden poseer memory protection unit.
- M4: Similares a los M3, levemente superiores. Agregan funciones como SIMD, soportan FPU por hardware e incluyen instrucciones para trabajar con aritmética saturada.

2. ¿Por qué se dice que el set de instrucciones Thumb permite mayor densidad de código?
Explique
El set de instrucciones Thumb está compuesto por un conjunto reducido de instrucciones de 16bits las cuales son las más comunes de utilizar.


			32bits			│\
Memoria Flash ───┬──────────────────────────────│ \
		 │				│  │
		 │		│\		│  │
		 │0:15bits	│ \		│  │─────────> Ejecución de la instrucción
		 ├──────────────│  │  32 bits	│  │
		 │		│  │────────────│ /
		 │16:32 bits	│  │		│/(**)
		 └──────────────│ /
		 		│/
				(*)
(*): Selección de primeros 2 o últimos 2 bytes de los 4 bytes guardados en la flash. Selecciona una instrucción u otra de 16 bits de una posición de memoria de 32bits.
     └─>A partir de la instrucción Thumb de 16bits construye su equivalente de 32 bits para ser ejecutado.
(**): Selecciona entre ejecutar directo de memoria Flash (32bits) o ejecutar de 2 bytes (16bits instrucciones Thumb).
Ej. de instrucción en 32bits vs 2 de 16 en thumb:
>> 32bits:
		┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
Instrcción #1:  │31│30│29│28│27│26│25│24│23│22│21│20│19│18│17│16│15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│	//Primeros 4 bytes
		└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
		┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
Instrcción #2:  │31│30│29│28│27│26│25│24│23│22│21│20│19│18│17│16│15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│	//Segundos 4 bytes
		└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
>> Thumb (16bits):
		┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐ ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
Instrcción #1:  │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│ │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│-> Instrucción #2	//Primeros 4 bytes
		└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘ └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
		┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐ ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
Instrcción #3:  │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│ │15│14│13│12│11│10│ 9│ 8│ 7│ 6│ 5│ 4│ 3│ 2│ 1│ 0│-> Instrucción #4	//Segundos 4 bytes
		└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘ └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
Conclusión: Se consigue mayor densidad de instrucciones en igual capacidad de memoria de programa.
Como desventajas, estas instrucciones son reducidas, no están "traducidas" a Thumb el 100% de las instrucciones de 32bits.
Por lo que para ciertas acciones a realizar por el código, puede consumir más instrucciones en Thumb que en 32bits.

3. ¿Qué entiende por arquitectura load-store? ¿Qué tipo de instrucciones no posee este
tipo de arquitectura?
La arquitectura de ARM no trabaja directamente con los datos guardados en RAM, sino que trabaja con los registros.
Para esto se tienen tres pasos:
> 1: Para acceder a los datos se utiliza la función de "load" la cual mueve un valor guardado en RAM a un registro, generalmente de 0 a 12 y en el caso de Thumb de 0 a7.
> 2: Se opera con los valores que se encuentran en los registros de propósito general.
> 3: De requerirse, se guarda el resultado en RAM moviendo el valor desde uno de los registros de propósito general con la función "store".
Existen distintas funciones para movimiento de datos:

REG  ‐‐> REG: transferencia entre dos registros
MEM  ‐‐> REG: carga (load) 		>> De memoria a un registro para ser utilizado
PILA ‐‐> REG: extracción (pop)
REG  ‐‐> MEM: almacenamiento (store)	>> De un registro a memoria para ser almacenado
MEM  ‐‐> MEM: movimiento (move)
PILA ‐‐> MEM: extracción (pop)
REG  ‐‐> PILA: inserción (push)
MEM  ‐‐> PILA: inserción (push)

Existen operaciones que no requieren operar sobre registros y por ende no requiere una función load previa, por ejemplo NOP.

4. ¿Cómo es el mapa de memoria de la familia? 
Dado la arquitectura de 32bits, se poseen 2^32 (4.294.967.296) posiciones de memoria, lo que corresponde a 4GB.
Dentro de la arquitectura ARMv7 correspondiente a M3 y M4:
Los primeros 0,5GB corresponden a memoria de programa, luego 0,5 a SRAM, 0,5 Perisféricos, 1G RAM, 1GB para dispositivos y 0,5GB específico para el sistema.

  	    ┌────────┐
0xFFFFFFFF  │ 	     │
	    │ System │	0,5GB
0xE0000000  │        │
	    ├────────┤
0xDFFFFFFF  │ 	     │
	    │ Devices│	1GB
0xA0000000  │        │
	    ├────────┤
0x9FFFFFFF  │ 	     │
	    │ RAM    │	1GB
0x60000000  │        │
	    ├────────┤
0x5FFFFFFF  │ 	     │
	    │ Perisfé│	0,5GB
0x40000000  │ -ricos │
	    ├────────┤
0x3FFFFFFF  │ 	     │
	    │ SRAM   │	0,5GB
0x20000000  │        │
	    ├────────┤
0x1FFFFFFF  │ 	     │
	    │ Código │	0,5GB
0x00000000  │        │
	    └────────┘
Dentro de SRAM y Perisféricos, el primer MB corresponde a bit band, manejados por las posiciones relativas de 32MB a 64MB de cada bloque.
